package provider

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/umputun/mpt/pkg/provider/enum"
)

func TestResult_Format(t *testing.T) {
	tests := []struct {
		name     string
		result   Result
		expected string
	}{
		{
			name: "success result",
			result: Result{
				Provider: "TestProvider",
				Text:     "This is a test response",
				Error:    nil,
			},
			expected: "== generated by TestProvider ==\nThis is a test response\n",
		},
		{
			name: "error result",
			result: Result{
				Provider: "TestProvider",
				Text:     "",
				Error:    assert.AnError,
			},
			expected: "== generated by TestProvider ==\nassert.AnError general error for testing\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			formatted := tt.result.Format()
			assert.Equal(t, tt.expected, formatted)
		})
	}
}

func TestSanitizeError(t *testing.T) {
	tests := []struct {
		name           string
		inputErr       error
		shouldSanitize bool
		checkProvider  bool // indicates if provider name should be checked in the error
	}{
		{
			name:           "nil error",
			inputErr:       nil,
			shouldSanitize: false,
		},
		{
			name:           "normal error",
			inputErr:       errors.New("normal error message"),
			shouldSanitize: false,
		},
		{
			name:           "error with API key",
			inputErr:       errors.New("error with api_key=1234567890"),
			shouldSanitize: true,
		},
		{
			name:           "error with bearer token",
			inputErr:       errors.New("error with bearer authentication"),
			shouldSanitize: true,
		},
		{
			name:           "error with provider prefix",
			inputErr:       errors.New("openai api error: key expired"),
			shouldSanitize: true,
			checkProvider:  true, // should contain "openai" in error
		},
		{
			name:           "error with URL containing token",
			inputErr:       errors.New("request to https://api.example.com/v1?access_token=abc123 failed"),
			shouldSanitize: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := SanitizeError(tt.inputErr)

			if tt.inputErr == nil {
				assert.NoError(t, result)
				return
			}

			if tt.shouldSanitize {
				// check that sanitized error contains required elements
				assert.Contains(t, result.Error(), "redacted", "Sanitized error should mention redaction")
				assert.Contains(t, result.Error(), "sensitive information", "Sanitized error should mention sensitive information")

				// if we need to check for provider name
				if tt.checkProvider {
					assert.Contains(t, result.Error(), "openai", "Sanitized error should preserve provider name")
				}
			} else {
				assert.Equal(t, tt.inputErr.Error(), result.Error(), "Non-sensitive errors should be unchanged")
			}
		})
	}
}

func TestOptions_Validate(t *testing.T) {
	tests := []struct {
		name         string
		opts         Options
		providerType enum.ProviderType
		wantErr      bool
		errContains  string
	}{
		{
			name: "valid options",
			opts: Options{
				APIKey:  "test-key",
				Enabled: true,
				Model:   "test-model",
			},
			providerType: enum.ProviderTypeOpenAI,
			wantErr:      false,
		},
		{
			name: "not enabled",
			opts: Options{
				APIKey:  "test-key",
				Enabled: false,
				Model:   "test-model",
			},
			providerType: enum.ProviderTypeOpenAI,
			wantErr:      true,
			errContains:  "is not enabled",
		},
		{
			name: "missing api key",
			opts: Options{
				Enabled: true,
				Model:   "test-model",
			},
			providerType: enum.ProviderTypeAnthropic,
			wantErr:      true,
			errContains:  "api key for anthropic provider is required",
		},
		{
			name: "missing model",
			opts: Options{
				APIKey:  "test-key",
				Enabled: true,
			},
			providerType: enum.ProviderTypeGoogle,
			wantErr:      true,
			errContains:  "model for google provider is required",
		},
		{
			name: "empty api key",
			opts: Options{
				APIKey:  "",
				Enabled: true,
				Model:   "test-model",
			},
			providerType: enum.ProviderTypeOpenAI,
			wantErr:      true,
			errContains:  "api key for openai provider is required",
		},
		{
			name: "empty model",
			opts: Options{
				APIKey:  "test-key",
				Enabled: true,
				Model:   "",
			},
			providerType: enum.ProviderTypeAnthropic,
			wantErr:      true,
			errContains:  "model for anthropic provider is required",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.opts.Validate(tt.providerType)
			if tt.wantErr {
				require.Error(t, err)
				if tt.errContains != "" {
					assert.Contains(t, err.Error(), tt.errContains)
				}
			} else {
				require.NoError(t, err)
			}
		})
	}
}

func TestCreateProvider(t *testing.T) {
	tests := []struct {
		name         string
		providerType enum.ProviderType
		opts         Options
		wantErr      bool
		errContains  string
		checkType    string // expected provider type name
	}{
		{
			name:         "create openai provider",
			providerType: enum.ProviderTypeOpenAI,
			opts: Options{
				APIKey:      "test-openai-key",
				Enabled:     true,
				Model:       "gpt-4",
				MaxTokens:   1000,
				Temperature: 0.7,
			},
			wantErr:   false,
			checkType: "OpenAI",
		},
		{
			name:         "create anthropic provider",
			providerType: enum.ProviderTypeAnthropic,
			opts: Options{
				APIKey:    "test-anthropic-key",
				Enabled:   true,
				Model:     "claude-3",
				MaxTokens: 2000,
			},
			wantErr:   false,
			checkType: "Anthropic",
		},
		{
			name:         "create google provider",
			providerType: enum.ProviderTypeGoogle,
			opts: Options{
				APIKey:    "test-google-key",
				Enabled:   true,
				Model:     "gemini-pro",
				MaxTokens: 1500,
			},
			wantErr:   false,
			checkType: "Google",
		},
		{
			name:         "unsupported provider type",
			providerType: enum.ProviderTypeCustom,
			opts: Options{
				APIKey:  "test-key",
				Enabled: true,
				Model:   "test-model",
			},
			wantErr:     true,
			errContains: "unsupported provider type",
		},
		{
			name:         "validation failed - no api key",
			providerType: enum.ProviderTypeOpenAI,
			opts: Options{
				Enabled: true,
				Model:   "gpt-4",
			},
			wantErr:     true,
			errContains: "provider validation failed",
		},
		{
			name:         "validation failed - not enabled",
			providerType: enum.ProviderTypeAnthropic,
			opts: Options{
				APIKey:  "test-key",
				Enabled: false,
				Model:   "claude-3",
			},
			wantErr:     true,
			errContains: "provider validation failed",
		},
		{
			name:         "validation failed - no model",
			providerType: enum.ProviderTypeGoogle,
			opts: Options{
				APIKey:  "test-key",
				Enabled: true,
			},
			wantErr:     true,
			errContains: "provider validation failed",
		},
		{
			name:         "unknown provider type",
			providerType: enum.ProviderTypeUnknown,
			opts: Options{
				APIKey:  "test-key",
				Enabled: true,
				Model:   "test-model",
			},
			wantErr:     true,
			errContains: "unsupported provider type",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			provider, err := CreateProvider(tt.providerType, tt.opts)

			if tt.wantErr {
				require.Error(t, err)
				assert.Nil(t, provider)
				if tt.errContains != "" {
					assert.Contains(t, err.Error(), tt.errContains)
				}
			} else {
				require.NoError(t, err)
				assert.NotNil(t, provider)
				assert.Equal(t, tt.checkType, provider.Name())
				assert.True(t, provider.Enabled())
			}
		})
	}
}
