package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/umputun/mpt/pkg/provider/enum"
)

//go:generate go run github.com/go-pkgz/enum@latest -type=providerType -lower -path=enum

// Provider defines the interface for LLM providers
type Provider interface {
	Name() string
	Generate(ctx context.Context, prompt string) (string, error)
	Enabled() bool
}

// providerType is the base type for the generated enum
// Used by go:generate - this type and constants are used by the enum generator
// nolint:unused // These are used by the enum generator but not directly in the code
type providerType uint8

// nolint:unused // These constants are used by the enum generator but not directly in the code
const (
	providerTypeUnknown providerType = iota
	providerTypeOpenAI
	providerTypeAnthropic
	providerTypeGoogle
	providerTypeCustom
)

// Result represents a generation result from a provider
type Result struct {
	Provider string
	Text     string
	Error    error
}

// Format formats a result for output with a provider header
func (r Result) Format() string {
	if r.Error != nil {
		return fmt.Sprintf("== generated by %s ==\n%v\n", r.Provider, r.Error)
	}
	return fmt.Sprintf("== generated by %s ==\n%s\n", r.Provider, r.Text)
}

// Options defines common options for all providers
type Options struct {
	APIKey      string
	Enabled     bool
	Model       string
	MaxTokens   int     // maximum number of tokens to generate
	Temperature float32 // controls randomness (0-1, default: 0.7)
}

// Validate checks if the provider options are valid
func (o Options) Validate(providerType enum.ProviderType) error {
	providerName := providerType.String()

	if !o.Enabled {
		return fmt.Errorf("provider %s is not enabled (use --%s.enabled flag to enable)",
			providerName, providerName)
	}

	if o.APIKey == "" {
		return fmt.Errorf("api key for %s provider is required (set with --%s.api-key flag or %s_API_KEY env var)",
			providerName, providerName, strings.ToUpper(providerName))
	}

	if o.Model == "" {
		return fmt.Errorf("model for %s provider is required (set with --%s.model flag or %s_MODEL env var)",
			providerName, providerName, strings.ToUpper(providerName))
	}

	return nil
}

// CreateProvider creates a standard provider (OpenAI, Anthropic, Google)
// based on the provider type and options. It validates required fields
// and returns appropriate errors if validation fails.
func CreateProvider(providerType enum.ProviderType, opts Options) (Provider, error) {
	// validate options - adds detailed error context for each validation failure
	if err := opts.Validate(providerType); err != nil {
		return nil, fmt.Errorf("provider validation failed: %w", err)
	}

	switch providerType {
	case enum.ProviderTypeOpenAI:
		// detailed context for each provider type
		p := NewOpenAI(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("openai provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	case enum.ProviderTypeAnthropic:
		p := NewAnthropic(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("anthropic provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	case enum.ProviderTypeGoogle:
		p := NewGoogle(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("google provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	default:
		return nil, fmt.Errorf("unsupported provider type %q - valid types are 'openai', 'anthropic', or 'google'", providerType)
	}
}
