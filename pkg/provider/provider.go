package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/umputun/mpt/pkg/provider/enum"
)

//go:generate go run github.com/go-pkgz/enum@latest -type=providerType -lower -path=enum

// Provider defines the interface for LLM providers
type Provider interface {
	Name() string
	Generate(ctx context.Context, prompt string) (string, error)
	Enabled() bool
}

// providerType is the base type for the generated enum
// Used by go:generate - this type and constants are used by the enum generator
// nolint:unused // These are used by the enum generator but not directly in the code
type providerType uint8

// nolint:unused // These constants are used by the enum generator but not directly in the code
const (
	providerTypeUnknown providerType = iota
	providerTypeOpenAI
	providerTypeAnthropic
	providerTypeGoogle
	providerTypeCustom
)

// Result represents a generation result from a provider
type Result struct {
	Provider string
	Text     string
	Error    error
}

// Format formats a result for output with a provider header
func (r Result) Format() string {
	if r.Error != nil {
		return fmt.Sprintf("== generated by %s ==\n%v\n", r.Provider, r.Error)
	}
	return fmt.Sprintf("== generated by %s ==\n%s\n", r.Provider, r.Text)
}

// Options defines common options for all providers
type Options struct {
	APIKey      string
	Enabled     bool
	Model       string
	MaxTokens   int     // maximum number of tokens to generate
	Temperature float32 // controls randomness (0-1, default: 0.7)
}

// Validate checks if the provider options are valid
func (o Options) Validate(providerType enum.ProviderType) error {
	providerName := providerType.String()

	if !o.Enabled {
		return fmt.Errorf("provider %s is not enabled (use --%s.enabled flag to enable)",
			providerName, providerName)
	}

	if o.APIKey == "" {
		return fmt.Errorf("api key for %s provider is required (set with --%s.api-key flag or %s_API_KEY env var)",
			providerName, providerName, strings.ToUpper(providerName))
	}

	if o.Model == "" {
		return fmt.Errorf("model for %s provider is required (set with --%s.model flag or %s_MODEL env var)",
			providerName, providerName, strings.ToUpper(providerName))
	}

	return nil
}

// SanitizeError cleans API error messages to prevent leaking sensitive information
// such as API keys, tokens, and other credentials.
func SanitizeError(err error) error {
	if err == nil {
		return nil
	}

	// convert error to string to analyze and sanitize
	errStr := err.Error()

	// list of patterns to sanitize (partial keys, tokens, credentials)
	sensitivePatterns := []string{
		// API Key patterns
		"sk-", "key-", "api_key", "apikey", "api-key", "token", "secret", "key",
		// authentication patterns
		"auth", "bearer", "password", "credential",
		// URL patterns with potential token/key in query params
		"?key=", "&key=", "access_token=", "secret=",
	}

	// check if error contains any sensitive information
	containsSensitiveInfo := false
	for _, pattern := range sensitivePatterns {
		if strings.Contains(strings.ToLower(errStr), strings.ToLower(pattern)) {
			containsSensitiveInfo = true
			break
		}
	}

	// if sensitive info is found, replace it with a more informative generic message
	if containsSensitiveInfo {
		// get the provider name if present at the start of the error message
		// common format: "provider api error: ..."
		providerPrefix := ""
		errorType := "authentication"
		
		// try to extract provider name and determine error type for better context
		if parts := strings.SplitN(errStr, " api error:", 2); len(parts) > 1 {
			providerPrefix = parts[0]
			
			// check for common error patterns to provide better guidance
			errorPart := strings.ToLower(parts[1])
			switch {
			case strings.Contains(errorPart, "authenticat") || strings.Contains(errorPart, "auth") || 
				 strings.Contains(errorPart, "key") || strings.Contains(errorPart, "token"):
				errorType = "authentication"
			case strings.Contains(errorPart, "model"):
				errorType = "model selection"
			case strings.Contains(errorPart, "rate") || strings.Contains(errorPart, "limit"):
				errorType = "rate limit"
			case strings.Contains(errorPart, "timeout") || strings.Contains(errorPart, "timed out"):
				errorType = "timeout"
			}
			
			return fmt.Errorf("%s API error: possible %s issue - the original error was redacted to protect sensitive information. Check your API key and configuration", 
				providerPrefix, errorType)
		}
		
		return fmt.Errorf("API error: possible %s issue - the original error was redacted to protect sensitive information. Check your provider configuration", 
			errorType)
	}

	// if no sensitive information is detected, return the original error
	return err
}

// CreateProvider creates a standard provider (OpenAI, Anthropic, Google)
// based on the provider type and options. It validates required fields
// and returns appropriate errors if validation fails.
func CreateProvider(providerType enum.ProviderType, opts Options) (Provider, error) {
	// validate options - adds detailed error context for each validation failure
	if err := opts.Validate(providerType); err != nil {
		return nil, fmt.Errorf("provider validation failed: %w", err)
	}

	switch providerType {
	case enum.ProviderTypeOpenAI:
		// detailed context for each provider type
		p := NewOpenAI(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("openai provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	case enum.ProviderTypeAnthropic:
		p := NewAnthropic(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("anthropic provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	case enum.ProviderTypeGoogle:
		p := NewGoogle(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("google provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	default:
		return nil, fmt.Errorf("unsupported provider type %q - valid types are 'openai', 'anthropic', or 'google'", providerType)
	}
}
