package provider

import (
	"context"
	"fmt"
	"strings"
)

//go:generate go run github.com/go-pkgz/enum@latest -type=providerType -lower
//go:generate moq -out mocks/provider.go -pkg mocks -skip-ensure -fmt goimports . Provider

// Provider defines the interface for LLM providers
type Provider interface {
	Name() string
	Generate(ctx context.Context, prompt string) (string, error)
	Enabled() bool
}

// providerType is the private type for enum generation
// The generator will create a public ProviderType in the enum package
//
//nolint:unused // used by enum generator
type providerType uint8

// Constants for enum generation - must be prefixed with type name
//
//nolint:unused // used by enum generator
const (
	providerTypeUnknown providerType = iota
	providerTypeOpenAI
	providerTypeAnthropic
	providerTypeGoogle
	providerTypeCustom
)

// Result represents a generation result from a provider
type Result struct {
	Provider string
	Text     string
	Error    error
}

// Format formats a result for output with a provider header
func (r Result) Format() string {
	if r.Error != nil {
		return fmt.Sprintf("== generated by %s ==\n%v\n", r.Provider, r.Error)
	}
	return fmt.Sprintf("== generated by %s ==\n%s\n", r.Provider, r.Text)
}

// Options defines common options for all providers
type Options struct {
	APIKey      string
	Enabled     bool
	Model       string
	MaxTokens   int     // maximum number of tokens to generate
	Temperature float32 // controls randomness (0-1, default: 0.7)
}

// Validate checks if the provider options are valid
func (o Options) Validate(providerType ProviderType) error {
	providerName := providerType.String()

	if !o.Enabled {
		return fmt.Errorf("provider %s is not enabled (use --%s.enabled flag to enable)",
			providerName, providerName)
	}

	if o.APIKey == "" {
		return fmt.Errorf("api key for %s provider is required (set with --%s.api-key flag or %s_API_KEY env var)",
			providerName, providerName, strings.ToUpper(providerName))
	}

	if o.Model == "" {
		return fmt.Errorf("model for %s provider is required (set with --%s.model flag or %s_MODEL env var)",
			providerName, providerName, strings.ToUpper(providerName))
	}

	return nil
}

// CreateProvider creates a standard provider (OpenAI, Anthropic, Google)
// based on the provider type and options. It validates required fields
// and returns appropriate errors if validation fails.
func CreateProvider(providerType ProviderType, opts Options) (Provider, error) {
	// validate options - adds detailed error context for each validation failure
	if err := opts.Validate(providerType); err != nil {
		return nil, fmt.Errorf("provider validation failed: %w", err)
	}

	switch providerType {
	case ProviderTypeOpenAI:
		// detailed context for each provider type
		p := NewOpenAI(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("openai provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	case ProviderTypeAnthropic:
		p := NewAnthropic(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("anthropic provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	case ProviderTypeGoogle:
		p := NewGoogle(opts)
		if !p.Enabled() {
			return nil, fmt.Errorf("google provider failed to initialize with model %q - check API key and model name", opts.Model)
		}
		return p, nil
	default:
		return nil, fmt.Errorf("unsupported provider type %q - valid types are 'openai', 'anthropic', or 'google'", providerType)
	}
}

// FindProviderByName searches for a provider by name (case-insensitive partial match)
// among the given providers. It returns the first enabled provider that matches.
// If no match is found, it returns the first enabled provider as a fallback.
// Returns nil if no enabled providers are available.
func FindProviderByName(name string, providers []Provider) Provider {
	nameLower := strings.ToLower(name)

	// first try to find an exact or partial match
	for _, p := range providers {
		if p.Enabled() && strings.Contains(strings.ToLower(p.Name()), nameLower) {
			return p
		}
	}

	// if no match found, return first enabled provider
	for _, p := range providers {
		if p.Enabled() {
			return p
		}
	}

	return nil
}
