// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/umputun/mpt/pkg/provider"
	"sync"
)

// Ensure, that ProviderMock does implement provider.Provider.
// If this is not the case, regenerate this file with moq.
var _ provider.Provider = &ProviderMock{}

// ProviderMock is a mock implementation of provider.Provider.
//
//	func TestSomethingThatUsesProvider(t *testing.T) {
//
//		// make and configure a mocked provider.Provider
//		mockedProvider := &ProviderMock{
//			EnabledFunc: func() bool {
//				panic("mock out the Enabled method")
//			},
//			GenerateFunc: func(ctx context.Context, prompt string) (string, error) {
//				panic("mock out the Generate method")
//			},
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//		}
//
//		// use mockedProvider in code that requires provider.Provider
//		// and then make assertions.
//
//	}
type ProviderMock struct {
	// EnabledFunc mocks the Enabled method.
	EnabledFunc func() bool

	// GenerateFunc mocks the Generate method.
	GenerateFunc func(ctx context.Context, prompt string) (string, error)

	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Enabled holds details about calls to the Enabled method.
		Enabled []struct {
		}
		// Generate holds details about calls to the Generate method.
		Generate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Prompt is the prompt argument value.
			Prompt string
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
	lockEnabled  sync.RWMutex
	lockGenerate sync.RWMutex
	lockName     sync.RWMutex
}

// Enabled calls EnabledFunc.
func (mock *ProviderMock) Enabled() bool {
	if mock.EnabledFunc == nil {
		panic("ProviderMock.EnabledFunc: method is nil but Provider.Enabled was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEnabled.Lock()
	mock.calls.Enabled = append(mock.calls.Enabled, callInfo)
	mock.lockEnabled.Unlock()
	return mock.EnabledFunc()
}

// EnabledCalls gets all the calls that were made to Enabled.
// Check the length with:
//
//	len(mockedProvider.EnabledCalls())
func (mock *ProviderMock) EnabledCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEnabled.RLock()
	calls = mock.calls.Enabled
	mock.lockEnabled.RUnlock()
	return calls
}

// Generate calls GenerateFunc.
func (mock *ProviderMock) Generate(ctx context.Context, prompt string) (string, error) {
	if mock.GenerateFunc == nil {
		panic("ProviderMock.GenerateFunc: method is nil but Provider.Generate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Prompt string
	}{
		Ctx:    ctx,
		Prompt: prompt,
	}
	mock.lockGenerate.Lock()
	mock.calls.Generate = append(mock.calls.Generate, callInfo)
	mock.lockGenerate.Unlock()
	return mock.GenerateFunc(ctx, prompt)
}

// GenerateCalls gets all the calls that were made to Generate.
// Check the length with:
//
//	len(mockedProvider.GenerateCalls())
func (mock *ProviderMock) GenerateCalls() []struct {
	Ctx    context.Context
	Prompt string
} {
	var calls []struct {
		Ctx    context.Context
		Prompt string
	}
	mock.lockGenerate.RLock()
	calls = mock.calls.Generate
	mock.lockGenerate.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *ProviderMock) Name() string {
	if mock.NameFunc == nil {
		panic("ProviderMock.NameFunc: method is nil but Provider.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedProvider.NameCalls())
func (mock *ProviderMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}
